# DailyCheck 后端接口文档

## 通用说明

- 基础地址：`https://{host}:{port}`（本地调试通常是 `https://localhost:5001` 或 `https://localhost:7200` 等）
- 所有接口返回 JSON
- 时间、日期字段采用 ISO 格式：`yyyy-MM-dd`（对应后端的 `DateOnly`）
- 受保护接口需要在请求头中携带 JWT：

  - Header：`Authorization: Bearer {token}`
  - `{token}` 由登录 / 注册接口返回
- 静态资源 / 图片访问规则：

  - 图片不会直接暴露在 `wwwroot` 静态目录下，而是按用户隔离存储
  - 所有图片访问统一通过受保护接口 `GET /mm/Files/images/{fileKey}` 完成
  - 上传接口返回的 `url` 为相对路径（形如 `/mm/files/images/{fileKey}`），前端可直接作为图片 `src` 使用

---

## 认证模块（AuthController）

基址：`/mm/Auth`

### 1. 用户注册

- 方法：`POST`
- 路径：`/mm/Auth/register`
- 认证：否

**请求体（JSON）**

```json
{
  "email": "user@example.com",
  "password": "string",
  "NickName": "可选昵称",
  "UserAccount": "账号名",
  "code": "123456"
}
```

字段说明：

- `email`：必填，用户邮箱
- `password`：必填，登录密码
- `NickName`：可选，用户昵称
- `UserAccount`：可选，用户账号名；如提供则需全局唯一
- `code`：必填，邮箱验证码（通过 `/mm/Auth/email-code` 获取）

**成功响应 200（JSON）**

```json
{
  "userId": 1,
  "email": "user@example.com",
  "NickName": "昵称",
  "UserAccount": "账号名",
  "AvatarKey": "头像 URL",
  "token": "短期访问 token",
  "refreshToken": "长期刷新 token",
  "accessTokenExpiresAt": "2024-01-01T12:30:00Z",
  "refreshTokenExpiresAt": "2024-01-08T12:00:00Z"
}
```

说明：

- `token`：访问 token，有效期 30 分钟（默认）
- `refreshToken`：刷新 token，有效期 7 天（默认）
- 访问 token 过期后，使用 `refreshToken` 调用刷新接口获取新的 token

**可能的响应**

- `400 Bad Request`：邮箱或密码为空；验证码为空、已过期或无效
- `409 Conflict`：邮箱已被注册；用户名已被占用

### 2. 用户登录（邮箱登录）

- 方法：`POST`
- 路径：`/mm/Auth/login`
- 认证：否

**请求体（JSON）**

```json
{
  "email": "user@example.com",
  "password": "string"
}
```

**成功响应 200（JSON）**

同注册接口，返回同样结构的 `AuthResponse`：包含 `token`、`refreshToken`、过期时间等字段。

失败时可能返回：

- `401 Unauthorized`：账号不存在、密码错误、账号被禁用等

### 3. 用户登录（账号登录）

- 方法：`POST`
- 路径：`/mm/Auth/login-account`
- 认证：否

**请求体（JSON）**

```json
{
  "UserAccount": "account001",
  "password": "string"
}
```

说明：

- 使用在注册或资料更新时设置的 `UserAccount` 字段进行登录
- 校验规则与邮箱登录相同：账号不存在、密码错误、账号被禁用等情况都会返回 401

**成功响应 200（JSON）**

- 返回结构与邮箱登录完全相同，即 `AuthResponse`

失败时可能返回：

- `400 Bad Request`：用户名为空
- `401 Unauthorized`：账号不存在、密码错误、账号被禁用等

### 4. 验证账号名可用性

- 方法：`POST`
- 路径：`/mm/Auth/validate-account`
- 认证：否

**查询参数**

- `UserAccount`：必填，待验证的账号名

**成功响应 200 OK**

- 表示账号名可用（未被占用）

**可能的响应**

- `400 Bad Request`：账号名为空
- `409 Conflict`：账号名已存在

---

### 5. 刷新 token（双 token 单点登录）

- 方法：`POST`
- 路径：`/mm/Auth/refresh`
- 认证：否（使用 body 中的刷新 token）

**请求体（JSON）**

```json
{
  "refreshToken": "长期刷新 token"
}
```

**成功响应 200（JSON）**

返回结构与登录/注册相同：

```json
{
  "userId": 1,
  "email": "user@example.com",
  "NickName": "昵称",
  "UserAccount": "账号名",
  "AvatarKey": "更新后的头像 URL",
  "token": "新的短期访问 token",
  "refreshToken": "新的长期刷新 token",
  "accessTokenExpiresAt": "2024-01-02T12:30:00Z",
  "refreshTokenExpiresAt": "2024-01-09T12:00:00Z"
}
```

说明：

- 每次刷新都会生成一对新的 access/refresh token
- 服务端内部会只保留当前用户最后一次生成的 refresh token 标识
- 旧的 refresh token 将失效，实现“单点登录”（后登录的会踢掉前一次登录的会话）

**可能的响应**

- `401 Unauthorized`：刷新 token 无效；解析出的用户 ID 非法；用户不存在或已被伪删除；账号被冻结

---

### 6. 发送邮箱验证码

- 方法：`POST`
- 路径：`/mm/Auth/email-code`
- 认证：否

**请求体（JSON）**

```json
{
  "email": "user@example.com",
  "actionType": "register"
}
```

字段说明：

- `email`：必填，接收验证码的邮箱地址
- `actionType`：可选，用途标识。支持：`register`、`signup`、`login`、`change-password`、`deactivate`、`reset-password`。为空时默认 `register`

用途说明：

- `register`/`signup`：邮箱必须未注册
- `login`/`change-password`/`deactivate`/`reset-password`：邮箱必须已注册

**可能的响应**

- `200 OK`：发送成功
- `400 Bad Request`：邮箱为空、用途不合法、邮箱状态与用途不匹配
- `429 Too Many Requests`：同一邮箱在 1 分钟内重复请求
- `500 Internal Server Error`：发送失败（如邮件服务异常）

### 7. 注销账号

- 方法：`POST`
- 路径：`/mm/Auth/deactivate`
- 认证：是

说明：

- 将当前登录用户标记为已注销（`isDeleted = 1`，`status = 0`），并记录伪删除日志
- 注销后用户无法再登录，已发放的刷新 token 也会在下一次刷新时失效

**请求体（JSON）**

```json
{
  "code": "123456"
}
```

字段说明：

- `code`：必填，邮箱验证码

**成功响应 204 No Content**

**可能的响应**

- `400 Bad Request`：验证码为空、已过期或不正确
- `404 Not Found`：未找到对应用户（一般仅在异常场景下出现）

### 8. 修改密码

- 方法：`POST`
- 路径：`/mm/Auth/change-password`
- 认证：是

**请求体（JSON）**

```json
{
  "oldPassword": "旧密码",
  "newPassword": "新密码",
  "code": "123456"
}
```

字段说明：

- `oldPassword`：可选，旧密码
- `newPassword`：必填，新密码
- `code`：可选，邮箱验证码

说明：

- `oldPassword` 与 `code` 至少提供一个，用于校验身份

**成功响应 204 No Content**

**可能的响应**

- `400 Bad Request`：新密码为空；未提供旧密码和验证码；验证码已过期或不正确
- `401 Unauthorized`：旧密码不正确或账号不可用
- `404 Not Found`：未找到对应用户

### 9. 更新用户信息

- 方法：`POST`
- 路径：`/mm/Auth/profile`
- 认证：是

**请求体（JSON）**

```json
{
  "NickName": "可选新昵称",
  "AvatarKey": "可选头像 URL"
}
```

字段说明：

- `NickName`：可选，新昵称；如省略则保持不变
- `AvatarKey`：可选，新头像地址；如省略则保持不变

**成功响应 200（JSON）**

返回结构与登录/注册相同：

```json
{
  "userId": 1,
  "email": "user@example.com",
  "NickName": "更新后的昵称",
  "UserAccount": "账号名",
  "AvatarKey": "更新后的头像 URL",
  "token": "新的短期访问 token",
  "refreshToken": "新的长期刷新 token",
  "accessTokenExpiresAt": "2024-01-02T12:30:00Z",
  "refreshTokenExpiresAt": "2024-01-09T12:00:00Z"
}
```

**可能的响应**

- `400 Bad Request`：请求参数错误

### 10. 获取当前用户基础信息

- 方法：`GET`
- 路径：`/mm/Auth/me`
- 认证：是

**成功响应 200（JSON）**

```json
{
  "userId": 1,
  "email": "user@example.com",
  "NickName": "昵称",
  "UserAccount": "账号名",
  "AvatarKey": "头像 URL"
}
```

**可能的响应**

- `401 Unauthorized`：账号被禁用
- `404 Not Found`：未找到对应用户

### 11. 检查账号名修改状态

- 方法：`GET`
- 路径：`/mm/Auth/account/status`
- 认证：是

**成功响应 200（JSON）**

```json
{
  "canUpdate": true,
  "nextUpdateAt": null
}
```

或不可修改时：

```json
{
  "canUpdate": false,
  "nextUpdateAt": "2025-02-09T10:00:00Z"
}
```

字段说明：

- `canUpdate`：当前是否可以修改账号名（一年一次限制）
- `nextUpdateAt`：如果不可修改，显示下一次允许修改的时间；如果可修改则为 `null`

### 12. 修改账号名

- 方法：`POST`
- 路径：`/mm/Auth/account`
- 认证：是

**请求体（JSON）**

```json
{
  "UserAccount": "new_account_name"
}
```

**成功响应 200（JSON）**

返回结构与登录/注册相同，包含更新后的用户信息和 Token。

**可能的响应**

- `400 Bad Request`：账号名为空
- `403 Forbidden`：修改过于频繁（未满一年），返回体包含 `nextUpdateAt`
- `409 Conflict`：账号名已被占用

---

## 打卡计划模块（PlansController）

基址：`/mm/Plans`

> 以下接口均需要在 Header 中携带 `Authorization: Bearer {token}`

### 3. 获取我的打卡计划列表

- 方法：`GET`
- 路径：`/mm/Plans`
- 认证：是

**成功响应 200（JSON）**

```json
[
  {
    "id": 1,
    "title": "早起打卡",
    "startDate": "2024-01-01",
    "endDate": "2024-02-01",
    "isActive": true,
    "timeSlots": [
      {
        "id": 10,
        "slotName": "早晨",
        "startTime": "09:00:00",
        "endTime": "10:00:00",
        "orderNum": 1,
        "isActive": true
      }
    ]
  }
]
```

字段说明：

- `id`：计划 ID
- `title`：计划标题
- `startDate`：开始日期
- `endDate`：结束日期（可为空）
- `isActive`：是否启用
- `timeSlots`：打卡时间段列表
  - `id`：时间段 ID
  - `slotName`：时间段名称
  - `startTime`：开始时间 (HH:mm:ss)
  - `endTime`：结束时间 (HH:mm:ss)
  - `orderNum`：排序号
  - `isActive`：是否启用

### 4. 创建打卡计划

- 方法：`POST`
- 路径：`/mm/Plans`
- 认证：是

**请求体（JSON）**

```json
{
  "title": "早起打卡",
  "description": "每天 7 点前起床",
  "startDate": "2024-01-01",  
  "endDate": "2024-02-01"
}
```

字段说明：

- `title`：必填，计划标题
- `description`：可选，计划描述
- `startDate`：可选，不填则默认为当天
- `endDate`：可选，计划结束日期

**成功响应 201（JSON）**

```json
{
  "id": 1,
  "title": "早起打卡",
  "startDate": "2024-01-01",
  "endDate": "2024-02-01",
  "isActive": true
}
```

### 5. 更新打卡计划

- 方法：`POST`
- 路径：`/mm/Plans/update`
- 认证：是

**请求体（JSON）**

```json
{
  "id": 1,
  "title": "早起打卡",
  "description": "每天 7 点前起床",
  "isActive": true,
  "startDate": "2024-01-01",  
  "endDate": "2024-02-01",
  "timeSlots": [
    {
      "slotName": "早晨",
      "startTime": "09:00:00",
      "endTime": "10:00:00",
      "orderNum": 1,
      "isActive": true
    }
  ]
}
```

字段说明：

- `id`：必填，计划 ID
- `title`：可选，计划标题
- `description`：可选，计划描述
- `isActive`：必填，是否启用
- `startDate`：可选，计划开始日期
- `endDate`：可选，计划结束日期
- `timeSlots`：可选，全量更新的时间段列表（会覆盖旧配置）

**成功响应 204 No Content**

### 6. 删除打卡计划

- 方法：`POST`
- 路径：`/mm/Plans/delete`
- 认证：是

**查询参数**

- `PlanId`：必填，计划 ID

**成功响应 204 No Content**

---

## 打卡模块（CheckinsController）

基址：`/mm/Checkins`

> 以下接口均需要在 Header 中携带 `Authorization: Bearer {token}`

### 7. 今日打卡

- 方法：`POST`
- 路径：`/mm/Checkins/daily`
- 认证：是

**请求体（JSON）**

```json
{
  "planId": 1,
  "imageUrls": [
    "/mm/files/images/2f5c1e4c3ea94c5f9e9d1b2d0d3e4f01"
  ],
  "note": "今天按时完成"
}
```

字段说明：

- `planId`：必填，打卡计划 ID
- `imageUrls`：可选，打卡图片 URL 列表
- `note`：可选，备注

**可能的响应**

- `200 OK`：打卡成功
- `400 Bad Request`：计划未开始；当天已打卡等
- `404 Not Found`：计划不存在
- `409 Conflict`：重复打卡

> 图片推荐流程：
>
> 1. 先调用 `POST /mm/Files/images` 上传图片，拿到图片 URL
> 2. 再把图片 URL 填到 `imageUrls` 数组里调用本接口

### 8. 补打卡（Retro）

- 方法：`POST`
- 路径：`/mm/Checkins/retro`
- 认证：是

**请求体（JSON）**

```json
{
  "planId": 1,
  "date": "2024-01-10",
  "imageUrls": [
    "/mm/files/images/2f5c1e4c3ea94c5f9e9d1b2d0d3e4f01"
  ],
  "note": "昨天忘记打了"
}
```

字段说明：

- `planId`：必填，打卡计划 ID
- `date`：必填，需要补打卡的日期（必须是过去一天以内）
- `imageUrls`：可选，图片 URL 列表
- `note`：可选，备注

**可能的响应**

- `200 OK`：补打卡成功
- `400 Bad Request`：日期不是过去；超过 24 小时；补打卡次数限制等
- `404 Not Found`：计划不存在
- `409 Conflict`：该日期已经存在打卡记录

> 图片推荐流程同上：先通过 `POST /mm/Files/images` 上传拿到 URL，再提交本接口

### 9. 获取打卡日历状态

- 方法：`GET`
- 路径：`/mm/Checkins/calendar`
- 认证：是

**查询参数**

- `planId`：必填，打卡计划 ID
- `year`：必填，年份（如 `2024`）
- `month`：必填，月份（1-12）

示例请求：

```http
GET /mm/Checkins/calendar?planId=1&year=2024&month=1
Authorization: Bearer {token}
```

**成功响应 200（JSON）**

```json
[
  {
    "date": "2024-01-01",
    "status": 1
  },
  {
    "date": "2024-01-02",
    "status": 2
  }
]
```

字段说明：

- `date`：日期
- `status`：状态（1=正常打卡，2=补打卡；其他状态可根据业务扩展）

---

### 10. 获取某日打卡详情

- 方法：`GET`
- 路径：`/mm/Checkins/detail`
- 认证：是

**查询参数**

- `planId`：必填，打卡计划 ID
- `date`：必填，需要查询的日期（格式：`yyyy-MM-dd`）

示例请求：

```http
GET /mm/Checkins/detail?planId=1&date=2024-01-02
Authorization: Bearer {token}
```

**成功响应 200（JSON）**

```json
{
  "date": "2024-01-02",
  "status": 1,
  "note": "今天按时完成",
  "imageUrls": [
    "/mm/files/images/2f5c1e4c3ea94c5f9e9d1b2d0d3e4f01",
    "/mm/files/images/6a7b8c9d0e1f234567890123456789ab"
  ]
}
```

字段说明：

- `date`：打卡日期
- `status`：状态（0=错过，1=正常打卡，2=补打卡）
- `note`：备注信息，可为空
- `imageUrls`：图片 URL 列表，如为空则返回空数组

**可能的响应**

- `200 OK`：查询成功
- `404 Not Found`：该日期没有打卡记录

---

## 文件上传模块（FilesController）

基址：`/mm/Files`

> 以下接口均需要在 Header 中携带 `Authorization: Bearer {token}`
 
### 11. 上传图片

- 方法：`POST`
- 路径：`/mm/Files/images`
- 认证：是
- 请求类型：`multipart/form-data`

**表单字段**

- 字段名：`file`
- 类型：文件（单个）

**限制说明**

- 单文件最大：10MB
- 允许的扩展名：`.jpg`、`.jpeg`、`.png`、`.gif`、`.webp`、`.bmp`
- **处理规则**：默认接受 WebP 文件；其他格式的图片将在上传后自动转换为 WebP 格式保存。

**成功响应 200（JSON）**

```json
{
  "url": "/mm/files/images/2f5c1e4c3ea94c5f9e9d1b2d0d3e4f01"
}
```

字段说明：

- `url`：图片的相对访问路径（例如 `/mm/files/images/{fileKey}`），可直接作为前端图片 `src`。
- **说明**：服务器会自动将上传的图片转换为 WebP 格式并存储，返回的 URL 不包含文件扩展名。

### 12. 获取图片

- 方法：`GET`
- 路径：`/mm/Files/images/{fileKey}`
- 认证：是

**路径参数**

- `fileKey`：必填，上传时返回的文件标识

**成功响应 200 OK**

- 返回图片二进制流
- `Content-Type`: 默认为 `image/webp`
- **说明**：所有新上传图片均以 WebP 格式存储。建议使用不带扩展名的 URL 访问。

### 13. 上传当前用户头像（公开）

- 方法：`POST`
- 路径：`/mm/Files/avatar`
- 认证：是

**表单字段**

- `file`：必填，图片文件

**成功响应 200（JSON）**

```json
{
  "key": "2f5c1e4c3ea94c5f9e9d1b2d0d3e4f01"
}
```

**说明**

- 上传成功后会自动更新当前登录用户的头像链接（`AvatarKey`）。
- 图片会被转换为 WebP 格式并存储在公开路径。
- 返回的 `key` 可用于后续获取头像。

### 14. 获取指定用户头像（公开）

- 方法：`GET`
- 路径：`/mm/Files/users/{userId}/{key}`
- 认证：否

**路径参数**

- `userId`：必填，指定的用户 ID
- `key`：必填，图片文件 Key

**成功响应 200 OK**

- 返回图片二进制流
- `Content-Type`: `image/webp`

**可能的响应**

- `404 Not Found`：图片文件不存在

---

## 快速使用建议

1. 调用 `POST /mm/Auth/register` 或 `POST /mm/Auth/login` 获取 `token`
2. 之后所有需要认证的接口，在 Header 中加上：

   - `Authorization: Bearer {token}`

3. 先创建计划：`POST /mm/Plans`
4. 上传图片（如有需要）：`POST /mm/Files/images` 拿到图片 URL
5. 再使用：

   - `POST /mm/Checkins/daily` 做每日打卡（带上图片 URL）
   - `POST /mm/Checkins/retro` 做补打卡（带上图片 URL）
   - `GET /mm/Checkins/calendar` 查询某月打卡情况
   - `GET /mm/Checkins/detail`?planId={planId}&date=YYYY-MM-DD 查询某天打卡详情

